#pragma once
#include <Memory/Hook.h>

struct ReticlePair
{
	unsigned short TableValue;
	unsigned short TableOffset;
};

namespace Exploits
{
	void Tick(APlayerController* PlayerController)
	{
		if (PlayerController)
		{
			static APlayerController* OldPlayerController = nullptr;
			static APlayerCameraManager* OldPlayerCameraManager = nullptr;

			static bool Update_FieldOfView = false;
			if (Settings::Exploits::CameraFOVChanger)
			{
				PlayerController->FOV(static_cast<float>(Settings::Exploits::CameraFOV));
				Update_FieldOfView = true;
			}
			else
			{
				if (Update_FieldOfView)
				{
					PlayerController->FOV(0.f);
					Update_FieldOfView = false;
				}
			}

			if (Settings::Exploits::NoRecoil)
			{
				*(BYTE*)(FortniteClientWin64Shipping + Offsets::bEnableRecoilDelay) = false;
			}

			bool DoExploits = Settings::Exploits::SilentAimbot || Settings::Exploits::ShootThroughWalls || Settings::Exploits::NoSpread || Settings::Exploits::HitSound;
			if (DoExploits)
			{
				APlayerPawn_Athena_C* AcknowledgedPawn = PlayerController->AcknowledgedPawn();
				if (AcknowledgedPawn)
				{
					AFortWeapon* CurrentWeapon = AcknowledgedPawn->CurrentWeapon();
					if (CurrentWeapon)
					{
						bool CurrentWeaponIsARanged = StaticClasses::GameplayStatics->ObjectIsA(CurrentWeapon, Classes::FortWeaponRanged);
						if (CurrentWeaponIsARanged)
						{
							bool IsHoldingPickaxe = StaticClasses::GameplayStatics->ObjectIsA(CurrentWeapon, Classes::WeaponPickaxeAthena);
							if (!IsHoldingPickaxe)
							{
								if (CurrentWeapon)
								{
									Hook::VTableHook().Hook( CurrentWeapon , HasInfiniteAmmo , 299 , &HasInfiniteAmmoOrignal );

									UFortWeaponItemDefinition* WeaponData = CurrentWeapon->WeaponData();
									if (WeaponData)
									{
										/*Hook::VTableHook().Hook(SomePointer, HasInfiniteReserveAmmo, 17, &HasInfiniteReserveAmmoOrignal);
										Hook::VTableHook().Hook( SomePointer , HasInfiniteMagazineAmmo , 18 , &HasInfiniteMagazineAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , UsesChargesForAmmo , 19 , &UsesChargesForAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , HasInfiniteCharges , 20 , &HasInfiniteChargesOrignal );
										Hook::VTableHook().Hook( SomePointer , UsesEnergyPoolForAmmo , 21 , &UsesEnergyPoolForAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , HasInfiniteEnergyPool , 22 , &HasInfiniteEnergyPoolOrignal );
										Hook::VTableHook().Hook( SomePointer , UsesConsumableAmmo , 23 , &UsesConsumableAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , HasInfiniteConsumables , 24 , &HasInfiniteConsumablesOrignal );
										Hook::VTableHook().Hook( SomePointer , InventoryOwnerHasInfiniteAmmo , 25 , &InventoryOwnerHasInfiniteAmmoOrignal );*/


									}
								}

								/*
								if ( Settings::Exploits::NoSpread )
								{
									auto ZeroReticle = [ ]( AFortWeapon* CurrentWeapon , unsigned short ValueOffset , unsigned short TableOffset )
										{
											auto ValueIndex = *( unsigned char* ) ( CurrentWeapon + TableOffset + 1 ) - ValueOffset;
											auto TableIndex = *( unsigned char* ) ( CurrentWeapon + TableOffset );
											auto TableEntry = ( CurrentWeapon + TableIndex * sizeof( unsigned long ) + TableOffset - 0x10 );

											auto SpreadKey = ValueIndex & 0x82FFFFFE | 0x4C000001;
											auto TableValue = *( int* ) ( TableEntry );

											auto SpreadUInt = SpreadKey ^ TableValue;
											auto CurrentSpread = *( float* ) ( &SpreadUInt );

											if ( CurrentSpread < 0.0f )
											{
												return;
											}

											float Value = 0.135f;
											auto RealValue = *( int* ) ( &Value ) ^ SpreadKey;
											*( int* ) ( TableEntry ) = RealValue;
										};

									static const ReticlePair Pairs[ ]
									{
										{ 0xA1D2, 0x1BC6 },
										{ 0xE572, 0x1BD8 },
										{ 0xE572, 0x1B62 },
										{ 0xE572, 0x1B74 },
										{ 0xE572, 0x1B86 },
										{ 0xE572, 0x1B98 },
									};

									for ( auto& RetPair : Pairs )
									{
										ZeroReticle( CurrentWeapon , RetPair.TableValue , RetPair.TableOffset );
									}
								}*/

								static AFortWeapon* OldCurrentWeapon = nullptr;
								if (CurrentWeapon != OldCurrentWeapon)
								{

									if ((Settings::Exploits::SilentAimbot || (Variables::BulletTraces::bEnableBulletTraces && !Settings::Exploits::SilentAimbot)))
									{

										

										//double* ReturnValue = GetWeaponTargetingTransformOriginal(CurrentWeapon, StartLocation, Angles);
										//if (Variables::GetWeaponTargetingTransform::bSilentAimActive && Variables::GetWeaponTargetingTransform::SilentLocationTarget)
										//{
										//	Angles[0] = Variables::GetWeaponTargetingTransform::SilentLocationTarget.X - StartLocation[0];
										//	Angles[1] = Variables::GetWeaponTargetingTransform::SilentLocationTarget.Y - StartLocation[1];
										//	Angles[2] = Variables::GetWeaponTargetingTransform::SilentLocationTarget.Z - StartLocation[2];
										//}


										if (!Settings::Developer::FreecamTestHook2)
										{
											//Hook::VTableHook().Hook(CurrentWeapon, GetWeaponTargetingTransform, Offsets::GetWeaponTargetingTransform, &GetWeaponTargetingTransformOriginal);
										}
										else
										{
											//Hook::VTableHook().Hook(CurrentWeapon, GetWeaponTargetingTransform, Offsets::GetWeaponTargetingTransformTest, &GetWeaponTargetingTransformOriginal);
										}
									}

									OldCurrentWeapon = CurrentWeapon;
								}
							}
						}
					}
				}
			}
		}
	}
}
